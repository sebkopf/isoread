% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/BinaryFileClass.R
\docType{class}
\name{BinaryFile}
\alias{BinaryFile}
\title{Binary File reference class}
\description{
Binary File reference class
}
\section{Fields}{

\describe{
\item{\code{filepath}}{stores the path to the binart file}

\item{\code{filename}}{stores the filename}

\item{\code{creation_date}}{stores the date the file was created (if it could be retrieved,
which is not always the case when running on linux but no problem on OS X and windows)}

\item{\code{rawdata}}{this is the binary raw data from the file (typically removed during cleanup
unless clean_raw = FALSE)}

\item{\code{keys}}{these are the Unicode and ASCII text fragments found in the binary file,
they are used for navigating in the file when pulling out the relevant data (typically
removed during cleanup unless clean_keys = FALSE)}

\item{\code{data}}{a list that contains all the actual data pulled from the file}
}}
\section{Methods}{

\describe{
\item{\code{clean_keys(removeText = NULL, removePattern = NULL, unlessByteLength = 0,
  unlessText = NULL)}}{clean up keys by removing randomly found strings that are clearly not proper targets}

\item{\code{cleanup(clean_raw = TRUE, clean_keys = TRUE, ...)}}{clean up the object by removing the raw data and keys (and other large but only transiently important information) from memory}

\item{\code{find_key(pattern, occurence = NULL, fixed = FALSE, byte_min = 0,
  byte_max = length(rawdata))}}{finds all keys matching 'key' or a specific occurence of it (use -1 for last occurence)
#' @param fixed whether to find the key(s) by regexp match or fixed string (default = pattern)
#' @param byte_min only look for keys that start after this position
#' @param byte_max only look for keys that start before this position
#' @return the lines of the keys data frame with all the information about the found key(s)}

\item{\code{find_keys(asciiL = 8, unicodeL = 5)}}{finds all unicode and ascii strings and stores them for navigation around the file}

\item{\code{get_info(show = c())}}{Get basic information about the object}

\item{\code{initialize(file, ...)}}{initialize BinaryFile object, requires a file path}

\item{\code{load(...)}}{load the data from the file and generate key lookup}

\item{\code{move_to_key(key, occurence = 1, fixed = TRUE)}}{moves position to the end of a specific key or occurence of a key 
#' @param key either a string or a data.frame line with key value and byteEnd (the way it is returned by find_key)
#' @param occurence if key is a string, which occurence to move to? (use -1 for last occurence)
#' @param fixed whether to find the key (if a string) by regexp match or fixed string (default = fixed string)}

\item{\code{parse(type, length = 1, id = NA, skip_first = 0)}}{parse binary data at current position in the data stream
      advances pointer by the size of the read data 

      #' @param type see \code{\link{map_binary_data_type}}
      #' @param length see \code{\link{parse_binary_data}}
      #' @param id if provided, will store the parsed data with this key in the \code{$data} field
      #' @param skip_first how many bytes to skip before reading this
      }

\item{\code{parse_array(types, n, id = NA, skip_first = 0)}}{repeatedly read the same set of information into a data frame

      #' @param types a named vector of data types (for data types see \code{\link{parse_binary_data}}), 
      #' the names are used for the columns of the resulting data frame
      #' @param id if provided, will store the parsed data with this key in the $data field
      #' @param n length of array
      #' @param skip_first how many bytes to skip before reading this}

\item{\code{process(...)}}{process the raw data to fill the data list}

\item{\code{read_file()}}{read the binary file

#' @note this does not work for very large files probably because of the 2^31-1 
#' limit on vector size! think about ways to fix this...
#' --> might have to acually read directly from the conection instead of the raw data buffer!}

\item{\code{skip(nbyte)}}{skip nbyte number of bytes in the raw data stream}
}}

